<p>
    Читая теорию по сервлетам, вы, скорее всего, уже успели наткнуться на пафосную фразу типа:
</p>

<div class="note_box left_note_box warning_box">
    <p>
        <q>
            ...Cервлет &mdash; это удивительный компонент Java платформы, который, являясь обычным Java-классом,
            тем не менее, способен обрабатывать запросы удаленных пользователей, отсылаемые по средствам сети интернет
            со всего мира...
        </q>
    </p>
</div>

<p>
    ну и так далее по тексту, очень похожему на кавказский тост
    <img alt="regular_smile" src="/assets/img/smiles/regular_smile.png" />.
    Как на нее не наткнуться, если примерно такая фраза встречается, чуть ли ни в первом абзаце любой книги по сервлетам.
</p>

<p>
    Однако давайте-ка присмотримся вот к этому моменту подробнее:
</p>

<div class="note_box left_note_box warning_box">
    <p>
        <q>...отсылаемые по средствам сети интернет со всего мира...</q>
    </p>
</div>

<p>
    Действительно, пользователей по всему миру очень много, и высока вероятность того,
    что один и тот же сервлет <b>одновременно</b> может понадобиться <b>сразу нескольким</b> людям.
    А сервлет-то всего один, и метод <code>service()</code>,
    который будет обрабатывать сразу несколько запросов &mdash; тоже один.
    Как быть в этой ситуации?
</p>

<p>
    Ну, конечно же, вы знаете как быть, так как, скорее всего, уже успели наткнуться еще на одну фразу,
    которая занимает второе место по популярности в любой <q>сервлетной книге</q>.
    Фраза куда менее пафосная, но зато куда более полезная:
</p>

<div class="note_box success_box">
    <p>
        Экземпляр сервлета на сервере создается только один,
        а для обработки каждого пользовательского запроса создается отдельный поток,
        в котором выполняется метод <code>service()</code>.
    </p>
</div>

<p>
    Далее, как правило, следует картинка, которая должна графически подтвердить то, что вы только что прочитали теоретически.
    Я, например, нашел в сети вот такой вариант:
</p>

<p class="change_text">КАРТИНКА</p>

<p>
    Картинка, не самая симпатичная, но я забрал ее с сайта компании
    <a href="http://oracle.com" target="_blank">Oracle</a>, которая по идее, не должна сильно расстраиваться,
    что ее графическими материалами рассказывают про ее же технологию.
</p>

<p>
    Но дело совершенно не в красоте мазков и стройности линий этой картины,
    а в том, что да &mdash; из изображения выше мы явно видим,
    что один и тот же сервлет может одновременно обрабатывать множество запросов,
    что приводит нас к следующему важному правилу:
</p>

<div class="note_box success_box">
    <p>
        Метод <code>service()</code> выполняется в многопоточной среде сервера,
        при этом в его сигнатуре отсутствует слово synchronized.
    </p>
</div>

<p>
    Это означает, что:
</p>

<div class="note_box danger_box">
    <p>
        метод <code>service()</code> не является потокобезопастным (Thread Safe),
        и любое обращение к полям сервлета из этого метода может нарушить корректное состояние этих полей.
    </p>
</div>

<p>
    Далее следуют рассуждения о том, что потокобезопастными могут быть сами поля, и в этой ситуации все будет нормально,
    но сейчас нам эти рассуждения не интересны, так как это не теория, а всего лишь раздел,
    который должен обозначить нам очередную проблему при выполнении практических заданий.
</p>

<p>
    А для того, чтобы наверняка понять проблему, давайте рассмотрим ее на простом жизненном примере.
    Пусть у нас есть сервлет со следующим исходным кодом:
</p>

<pre class="language-java line-numbers">
    <code class="language-java">
	public class HolydaysServlet extends HttpServlet {

		private Writer out;

		@Override
		protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
			// Устанавливаем кодировку для respons-а
			response.setCharacterEncoding("UTF-8");

			// получаем поток вывода
			out = response.getWriter();

			// Далее любой код вывода в out.
			// т. е. - в браузер клиента.
		}
	}
    </code>
</pre>

<p>
    Пусть этот сервлет делает самую важную и приятную работу в мире &mdash; шлет красивые поздравления от одних пользователей другим в любые праздники,
    которые только есть на нашей земле.
</p>

<p>
    Работать это может, например, так &mdash; пользователь вводит в поле ввода текст поздравления и email получателя,
    выбирает из имеющихся шаблонов внешний вид открытки и нажимает кнопку <q>Поздравить</q>.
    После чего сервлет накладывает текст поздравления на изображение открытки и отправляет ее по адресу получателя.
    Для полного драматизма момента, мы, конечно, выбираем самый романтический праздник на земле &mdash; <q>День Святого Валентина</q>!
</p>

<p>
    В чем же здесь драматизм? Да в том, что День Валентина для всех может проходить по-разному &mdash; для кого-то он самый лучший,
    а для кого-то наоборот &mdash; одни разочарования. Ну мало ли, что в жизни бывает...
    И вот представьте, что в этот день на двух разных концах планеты вашим сервлетом решили воспользоваться две девушки.
</p>

<p>
    Одна &mdash; абсолютно счастливая, специально встала пораньше, чтобы быстрее сказать <q>своему единственному</q>, как же сильно она его любит.
    И вторая &mdash; совершенно несчастная, поздно ночью, после долгих терзаний и не первой бутылки вина,
    решившаяся таки высказать <q>этому козлу</q> все, что она о нем думает.
    И вот они набирают текст:
</p>

<p>
    Первая:
</p>

<div class="note_box warning_box">
    <p>
        <q>Я так люблю тебя, мой зайчонок. Ты солнышко в моей жизни. Я твоя навек!</q>
    </p>
</div>

<p>
    И вторая:
</p>

<div class="note_box warning_box">
    <p>
        <q>Ненавижу тебя, скотина! Ты все разрушил! Тварь!!!</q>
    </p>
</div>

<p>
    И кнопку <q>Поздравить</q> они нажимают одновременно! О, сюжет достойный романа!..
    Однако давайте спускаться к проблемам нашего сервлета &mdash; они куда более приземленные.
    Что же произойдет после нажатия кнопки <q>Поздравить</q>?
</p>

<p>
    В следующий момент оба запроса придут на сервер, превратятся в потоки (<code>Thread</code>-ы)
    и каждый вызовет метод <code>service()</code>.
    Для большей достоверности давайте представим, что текст поздравления будет обрабатываться (ну для чего-то там, неважно для чего) пословно.
    Это значит, что когда начнет выполняться код из строк <b>#13-14</b> и т. д. (сам код нам сейчас не важен),
    то в поток вывода <code>out</code> каждый процесс начнет последовательно записывать по одному слову (или знаку препинания) из поздравления.
</p>

<p>
    Первая проблема здесь заключается в том, что потоки имеют особенность <q>засыпать</q> на определенное время в период своего выполнения.
    Это называется <q>квантование времени выполнения программ</q> (ну или как-то похоже на это).
    Более того, время, когда поток заснет, и сколько он будет спать, определяется
</p>

<div class="note_box danger_box">
    <p>
        операционной системой, а не нашей Java-программой
    </p>
</div>

<p>
    А это означает, что первый поток может заснуть, едва успев записать слово <q>Я</q>. И тут же просыпается второй поток. Вы понимаете, к чему я клоню?
</p>

<p>
    Естественно!
</p>

<div class="note_box danger_box">
    <p>
        ПОТОК ВЫВОДА У НАС ОДИН!
    </p>
</div>

<p>
    Он объявлен в строке <b>#3</b> и инициализируется в строке <b>#11</b>.
    Это &mdash; вторая и <b>основная</b> проблема нашего сервлета.
    Не будем проходить весь мучительный путь составления поздравления, а лучше попытаемся представить, что может получиться в результате:
</p>

<div class="note_box warning_box">
    <p>
        <q>Я так Ненавижу тебя, скотина! Ты солнышко все разрушил! в моей жизни Тварь!!!. навек!</q>
    </p>
</div>

<p>
    Господа, это же классическое поздравление Шредингера!
    Здесь даже не важно, кто его получит &mdash; вероятность потечь мозгом, равновысока у обоих получателей.
    Конечно, если сосед получателя &mdash; Шелдон Купер, волноваться не стоит &mdash;
    он все быстро и подробно сможет объяснить про поздравление Шредингера,
    но согласитесь &mdash; не всем же так везет! Итак, я думаю, мы готовы к выводу текущего раздела:
</p>

<div class="note_box danger_box">
    <p>
        Так как сервлет не является потокобезопасным объектом, использование полей в нем не допускается!
        Если в Вашем сервлете будут поля, принять такую работу я не смогу.
    </p>
</div>

<p>
    На самом деле, этот вывод не является абсолютно правильным. Он, скорее, наиболее простое решение для Вас.
    Ну, верно ведь, нет полей &mdash; нет проблем. Однако давайте кратко рассмотрим и другие выходы из сложившейся ситуации.
</p>

<p class="argument_header">
    1. Я буду сам заботиться о безопасности полей сервлета!
</p>

<p>
    Ну, вот как бы и да... Именно этот пункт и не делает предыдущий вывод абсолютно правильным.
    Действительно, Вы можете применять блоки синхронизации, использовать потокобезопасные коллекции или карты и так далее.
    Но зачем? Ведь подумайте, что такое поле?
</p>

<div class="note_box success_box">
    <p>
        Это возможность определить и сохранить состояние объекта.
    </p>
</div>

<p>
    А что такое протокол HTTP?
</p>

<div class="note_box success_box">
    <p>
        Это протокол, который не сохраняет свое состояние между запросами!
    </p>
</div>

<p>
    Так зачем же вам пытаться сохранять состояние в среде, которая
</p>

<div class="note_box danger_box">
    <p>
        не поддерживает сохранение состояния?
    </p>
</div>

<p>
    Но здесь у Вас может возникнуть встречные вопросы. Например:
</p>

<ul>
    <li>Как же тогда запомнить, что пользователь уже авторизовался и не просить его авторизоваться снова и снова при каждом переходе на новую страницу приложения?</li>
    <li>Как сформировать корзину покупателя, если он хочет приобрести больше одного товара?</li>
    <li>Как выбрать несколько моделей телефонов для сравнения характеристик?</li>
    <li>И так далее</li>
</ul>

<p>
    Таких вопросов может возникнуть очень много, и на все будет один ответ:
</p>

<p>
    Ознакомьтесь с объектом <code>javax.servlet.http.HttpSession</code>.
    Или проще говоря &mdash; с сессией клиента.
</p>

<p>
    Трех минут Вам будет достаточно, чтобы понять, что:
</p>

<div class="note_box success_box">
    <p>
        Сессия &mdash; это объект, который создается для каждого клиента в отдельном экземпляре.
    </p>
</div>

<p>
    Что она:
</p>

<div class="note_box success_box">
    <p>
        Существует все время работы клиента с приложением.
    </p>
</div>

<p>
    И что в нее:
</p>

<div class="note_box success_box">
    <p>
        Можно сохранять любые объекты, которые должны просуществовать в приложении на протяжении нескольких запросов.
    </p>
</div>

<p>
    Ну а если вы все таки решите <q>заботиться о потокобезопасности ваших полей</q>, не принять вашу работу, в конце концов, я не смогу,
    но я буду очень долго в ней разбираться и задавать Вам очень много вопросов <img alt="regular_smile" src="/assets/img/smiles/regular_smile.png" />.
</p>

<p class="argument_header">
    2. Вместо полей я буду использовать только локальные переменные!
</p>

<p>
    Сразу же &mdash; <b>стопроцентное ДА!!!</b>
    Я уверен, Вы прекрасно знаете, что не важно, сколько потоков одновременно вызывают один и тот же метод.
    Важно, что:
</p>

<div class="note_box success_box">
    <p>
        Для каждого потока в памяти создается уникальный набор всех локальных переменных для вызываемого метода!
    </p>
</div>

<p>
    А это значит, здесь у меня к вам никаких вопросов. Это стопроцентно рабочий вариант.
</p>

<p class="argument_header">
    3. Я буду объявлять поля, но использовать их только для чтения!
</p>

<p>
    Сразу же, <b>стопроцентное НЕТ!!!</b>
    Ох, как часто это бывает в реальной работе &mdash; только лишь один девелопер стыдливо подумает про себя:
</p>

<div class="note_box left_note_box warning_box">
    <p>
        <q>Ну я только одно поле объявлю... И то, писать в него ничего не буду... Ну я ж его только для чтения объявляю &mdash; тут дело понятное...</q>
    </p>
</div>

<p>
    Второй уже радостно трет руки:
</p>

<div class="note_box left_note_box warning_box">
    <p>
        <q>О, клево! Поле уже есть &mdash; объявлять ничего не надо. Записываем значение!</q>
    </p>
</div>

<p>
    В общем, получается примерно так &mdash; <q>полухороший подход всегда становится полуплохим!</q>
    Это аксиома, блин. Да и зачем вам поле только для чтения? Вывод &mdash; нет, так не пойдет.
</p>

<p class="argument_header">
    4. Я буду использовать константы.
</p>

<p>
    Ну а почему бы и нет? Если вам нужна константа в коде &mdash; лучший способ решить этот вопрос &mdash; это объявить константу в коде
    <img alt="regular_smile" src="/assets/img/smiles/regular_smile.png" />.
    Все мы понимаем, что такое выражение, как:
</p>

<pre class="language-java line-numbers">
    <code class="language-java">
	public static final int DAYS_IN_WEEK = 7;
    </code>
</pre>

<p>
    объявляет константу, которая инициализируется прямо в момент объявления, и изменить ее значение в последствии &mdash; невозможно.
</p>

<p>
    Так что тут &mdash; <b>стопроцентное да</b> в использовании такого подхода.
</p>

<p class="argument_header">
    5. Я буду использовать сессию.
</p>

<p>
    А, ну да... Я вам уже говорил.
    Ну тогда получается все &mdash; больше мне в этом разделе сказать вам нечего.
    Успехов вам в борьбе с сервлетными полями <img alt="regular_smile" src="/assets/img/smiles/regular_smile.png" />.
</p>
